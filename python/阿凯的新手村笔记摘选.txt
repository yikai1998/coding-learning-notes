【杂七杂八】
加速下载package
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/pygal


【常用运算符】
% 取模 
** 幂（返回X的Y次幂） 
a**b为‘a的b次方’ 
// 取整除 


【字符串】
print有一个参数end,默认是\n，可以改 
print(1, end = '') 
查找子字符串在大字符串的哪个位置 
print(msg.find('hello')) 
找到则返回找到字符的起始索引，没找到则返回 -1（不会报错） 
与index用法完全相同，但是index如果没找到，会报错 
rindex() 方法返回子字符串最后一次出现在字符串中的索引位置，该方法与 rfind() 方法一样，只不过如果子字符串不在字符串中会报一个异常。 


【列表】
往列表末尾增加"一个"元素 
msg.append('b') 
往指定索引位置的前面插入"一个"元素 
msg.insert(0,'aa') 
lista.insert(1, ['insert', 'one'])  # ['hello', ['insert', 'one'], 'world', 123]
往列表的末尾插入"多个"元素（输入形式为列表） 
lista = ['hello', 'world', 123]
lista.extend(['na', 'nm'])
lista.extend([['na', 'nm']])
lista.append(['na', 'nm'])
# ['hello', 'world', 123, 'na', 'nm', ['na', 'nm'], ['na', 'nm']]

删除的三种方法
del msg[0] 
msg.remove('qqq') 
msg.pop() 默认是-1，即最后一个元素 

清空列表 
msg = msg.clear 
msg.clear()


【字典】
value可以是任意的数据类型 
key通常应该是字符串类型 
用pop剔除，返回值是value。（实质上就是拿走了字典的value） 
popitem 剔除最后一对键值对. 返回值是一个元组  
print(info['name'])  如果没这个key会报错 
print(info.get('xxx')) 如果没这个key会返回none，不会报错 


【函数】
函数的使用必须遵循先定义，后调用的原则 
函数的定义阶段仅检测函数体的语法，不会执行 
函数的调用阶段：函数名 + () 
return是一个函数结束的标志，函数内可以有多个return 
return的返回值无类型限制 
0个return：返回None 
1个return：返回的值就是该值本身 
多个return：返回值是元组。如果想修改，外面加一个list就行，如 return [1, 2, 4]

在定义函数时，*代表收集参数，**代表收集关键字参数 
*将调用时提供的所有值，放在一个元组里 
def functiona(*params):
    print(params)
def functionb(**kwargs):
    print(kwargs)
functiona('hello', 'world')  # ('hello', 'world')
functionb(worda='hello', worldb='world')  # {'worda': 'hello', 'worldb': 'world'}

#里面函数得在外面函数运行之后再运行 
def first(): 
    print('aaa') 
    
    def second(): 
        print('bbb') 

    return second 

mid = first() 
mid() 

输出结果： 
aaa 
bbb 

# 同下
def first(func):
    def wrap():
        print('aaa')
        func()
    return wrap

@first
def second():
    print('bbb')

second()
输出结果：
aaa
bbb

我们可以将参数设置一个默认值，如果我们不填这个参数，那么这个值就是这个默认值。 
有默认值了的形参要放到后面 把没有默认值的形参放到前面 
*args 会把多输入的参数变成一个元组形式，需放在末尾 
**kargs 把传入的参数以键值对的形式存放到字典里 
def stu_register(name, age, course, *args, **kwargs):
    print(name, age, course, args, kwargs)
    print(f'Your Info: {args}')
    print(f'Your Info: {kwargs}')

stu_register('ben', 18, ' Math', 'CN', 'JP', hometown=['Shanghai', 'Anhui'], gender='Male')
# 这里不能画蛇添足写name='ben'之类的补足
# 你如果写成了stu_register(name='ben', age=18, course=' Math', args=('CN', 'JP'), hometown=['Shanghai', 'Anhui'], gender='Male')
# 则返回下面这个结果，明显不符合你的预期
ben 18  Math () {'args': ('CN', 'JP'), 'hometown': ['Shanghai', 'Anhui'], 'gender': 'Male'}
Your Info: ()
Your Info: {'args': ('CN', 'JP'), 'hometown': ['Shanghai', 'Anhui'], 'gender': 'Male'}

局部变量只在函数内部有效。函数已结束，这些变量也会跟着被释放掉 
变量的查找顺序：局部变量>全局变量 
函数中是无法修改全局变量的（如果硬要修改，可以在函数中用"global xxx"，即声明一个全局变量） 
name = 'ben chen'
def change_name():
    name = 'jack wang'
    print(f'my name is {name}')

change_name()
print(name)
结果是
my name is jack wang
ben chen

使用了global后
name = 'ben chen'
def change_name():
    global name
    name = 'jack wang'
    print(f'my name is {name}')

change_name()
print(name)
结果是
my name is jack wang
jack wang

# 这种办法可以改变全局变量
book_list = ['world travel', 'the second war', 'football']

def update_books(l):
    l.append('poem')

update_books(book_list)
print(book_list)
输出 ['world travel', 'the second war', 'football', 'poem']


【爬虫】
import requests
import os
desktop = os.path.join(os.path.expanduser('~'), 'Desktop')
headers = {
    'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Mobile Safari/537.36'
}
url = 'https://pic6.iqiyipic.com/image/20210916/1c/3f/v_108557140_m_601_m11_480_270.jpg?caplist=jpg,webp'
param = {
    'if': 'defaultQuery',
    'response_type': 2,
    'platform': 14,
    'is_qipu_platform': 1,
    'u': '3d6a60f7d9bac768fc1ee57fbd7cad8c',
    'cid': 0,
    'pu': '2064803180'
}
response = requests.get(url=url, params=param, headers=headers).content
# content返回的是二进制格式的图片数据
with open(f'{desktop}\\img.jpg', 'wb') as f:
    f.write(response)

bs4进行数据分析
实例化一个beautifulsoup对象，并将页面源码数据加载到该对象中。通过调用beautifulsoup对象中相关的属性或方法进行标签定位和数据提取。
from bs4 import BeautifulSoup
response = requests.get(url=url, headers=headers).text
soup = BeautifulSoup(response, 'lxml')
soup.tagName #返回文档中第一次出现的tagName对应的标签
soup.find() #e.g. soup.find('div',class_='song') 
soup.find_all() #返回符合要求的所有标签（列表）
soup.select('.tang') #输入某种选择器，返回一个列表
soup.select('.tang>ul>li>a') #层级选择器，>表示一个层级，(空格 表示多个层级，所以也可以写成soup.select('.tang>ul a')）
soup.a.text/string/get_text() #获取标签之间的文本数据
soup.a['href']#获取标签中的属性值

xpath解析
最常用，最高效，且通用性最高
实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中。结合着xpath方法，表达式。
from lxml import etree
parser = etree.HTMLParser(encoding="utf-8")
tree = etree.parse(r'C:\Users\Ben\Desktop\cosmetic_test.html', parser=parser)
r = tree.xpath('/html/body/div/table/tr[2]//text()')
xpath表达式：
'/' 表示一个层级
'//' 表示（从任意位置开始）多个层级
'/[@xxx="xxxx"]' 表示 属性定位
索引定位是从1开始的
'/text()' 可以获取标签中的直系文本内容
'//text()' 可以获取标签中的非直系文本内容（即：该标签下所有文本内容）#'/html/body/div/table/tr[2]//text()')
'/@属性名称'   # image/@src 可以返回对应的属性值


【内置函数】
abs()  # 取绝对值
all([, , , ,……])  # 所有都是True才返回True。0和None等同于False
any([, , , ,……])  # 任意一个是True则返回True
chr()  # 传ASCII码进去，打印出来字符
ord()  # 传字符进去，打印出来ASCII码
dict()  # 生成一个空字典，或将括号里的内容转换成字典
dir()  # 打印当前程序环境下内存里的所有变量，在一个列表里
locals()  # 打印当前程序的所有变量名及变量值,，在一个字典里
map()  # 把将一个可遍历的数据对象中的每一元素丢给某个函数运行
enumerate()  # 用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中
filter()  # 该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中
eval() #用来执行一个字符串表达式，并返回表达式的值
e.g. eval('2 + 2') 返回4


【模块和包】
import module_a  # 导入
from module import xx  # 导入某个模块下的某个方法或子模块
from module.xx.xx import xx as rename  # 导入某个方法后重命名
from module.xx.xx import *  # 导入一个模块下的所有方法
module_a.xxx  # 调用

只要import，就相当于执行了那个module的py文件

__file__  # 当前脚本的路径
__file__  # 当前脚本的文件夹路径
sys.path  # 模块的查找路径


