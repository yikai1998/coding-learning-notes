Synchronous - 同步 （类似 排队结账）    
一次只做一件事  
必须按顺序一件件做  

Asynchronous - 异步（类似 点晚餐后可以直接入座等餐，菜好了会直接端过来）  
做一件事情的时候，可以同时做其他事情  

---

process - 进程（一个独立的应用程序）  
有自己的内存空间  
相互之间独立  

thread - 线程（process里的工作人员）  
一个进程可以有多个线程  
所有的线程共享同一个内存空间  
可以同时执行不同的任务  

---

```py
from multiprocessing.dummy import Pool

# 创建线程池
pool = Pool(4)  # 4个线程的池

# 使用线程池执行任务
results = pool.map(some_function, list_of_items)
"""
一次处理多个项目
对列表中的每一项都执行同一个函数
返回一个包含所有结果的列表
默认会等待所有项目处理完成
"""


# 或者异步执行
pool.apply_async(some_function, args=(arg1, arg2), callback=on_complete)
"""
args=(arg1, arg2)
就是创建一个包含参数值的元组，系统会按照元组中值的顺序将它们传递给目标函数的参数。这种方式简单直接，只要确保元组中的值顺序与函数定义中的参数顺序一致即可。

如果您想用名称而不是位置来指定参数
thread = threading.Thread(target=greet, kwargs={"name": "Mary", "age": 22})
"""

"""
# 多次调用apply_async提交不同任务
# 不需要等待池中的任务完成，可以立即执行后续代码
# 回调函数会在主任务完成后自动执行，不需要您手动调用
with Pool(4) as pool:
    pool.apply_async(task1, args=(arg1,), callback=callback1)
    pool.apply_async(task2, args=(arg2,), callback=callback2)
# 这些任务会在池的4个线程中并发执行 当退出with块时，池会自动关闭
"""
```
- multiprocessing.dummy.Pool 虽然名字中有'multiprocessing'（多进程），但它实际上是一个线程池，不是进程池。'dummy'子模块是 multiprocessing 模块的一个特殊版本，它用线程代替了进程来实现并行操作。
- 预先创建固定数量的线程，重复使用它们
- 适合需要并行处理大量相似任务的情况
- 管理更方便，但灵活性稍低
- multiprocessing.dummy.Pool 内部实际上也是使用 threading.Thread 来创建线程的！它只是在此基础上添加了池管理功能

---

```py
import threading

# 创建并启动一个新线程
thread = threading.Thread(target=some_function, args=(arg1, arg2))
thread.start()

# 更简洁的一行写法
threading.Thread(target=some_function, args=(arg1, arg2)).start()
```
- 每次需要时手动创建一个新线程
- 适合偶尔需要的后台任务（如GUI响应）
- 对单个线程有更细粒度的控制
- 通常只需要偶尔运行一个后台任务（如API调用）
- 不需要管理线程生命周期（创建后运行完就结束）
- 代码更简洁直观

---

`pool.map` v.s. `pool.apply_async`
```py
# 使用map处理多个URL
urls = ["url1", "url2", "url3"]
results = pool.map(download_file, urls)  # 等待所有下载完成
for result in results:
    print(f"下载完成: {result}")

# 使用apply_async处理单个URL
pool.apply_async(download_file, args=(urls[0],) '''一个参数''', callback=on_complete)
print("下载已开始，程序继续运行...")  # 立即执行，不等待下载完成
```

如果on_complete也要接受参数，可以`callback=lambda result: handle_result(result, "任务A的后续", True) `，这个result参数自动接收process_item的返回值，如果要解包 可以直接类似`a, b, c = templist`后续处理。

---

```
用进程池的典型场景
Example 1：大数据/图片/加密/视频处理
每个ID是一张图片，要进行复杂的计算（如人脸识别、加密）。
每核CPU干一份，线程完全没用（GIL限制），必须进程池。
Example 2：Selenium、Chrome自动化、或Pyppeteer等浏览器
每个ID开一个浏览器（背后是Chrome/Edge独立进程），互相不干扰。
线程池很快乱，必须进程池！
Example 3：科学数值运算、机器学习
每个ID都在干重运算。
必须进程池！

用线程池的典型场景
假设有10个人要各自去窗口A办手续，然后再去窗口B。原来你让1个人办完A、等结果、再去B，10个顺序慢慢来；
现在你让他们排成队同时去A窗口，各自等自己的结果（比如用10个线程），谁A完成谁去B，这样总时间比“排队”要快了好多倍！
Example 1：API批量爬取
每个ID去GET/POST一个远端接口，主要时间都在“等服务器返回”，本地CPU很空闲。
用线程池能迅速发起N个“等”动作，CPU压力小。
Example 2：网络批量下载/上传文件
比如要下载1000个图片、视频，主要时间都在等下载完成，而不是靠CPU计算。
线程池超高效！
Example 3：文件批量读写、数据库批量入库
大多数时间都在等外部硬盘或数据库响应，不是本地算力瓶颈。
线程池即可！

concurrent.futures几乎能满足所有主流并发需求，一行切线程/进程池，现在首选推荐
语法统一，一行代码就能从线程池换到进程池，不需要改动任务函数！
支持as_completed、submit等特性，灵活，容易扩展
异常处理更优雅
Python 3标准库推荐方案
```

```py
# 线程池的例子（IO密集型，比如API批量采集）
import concurrent.futures
import requests

ids = ['id1', 'id2', 'id3', 'id4']

def fetch_apiA(id_):
    # 假定此处是你的API查询
    return requests.get(f'https://httpbin.org/get?id={id_}').json()

with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
    results = list(executor.map(fetch_apiA, ids))

for item in results:
    print(item)
```

```py
# 进程池一定加if __name__ == '__main__'
# 线程池：在自己屋里叫家人帮忙，大家都知道哪些事什么时候做，不会反复搬家；
# 进程池：每开一个工人，还得分配一个新房子（新起脚本），如果没加保护，那每个房子都再建房子……整个小区无限递归，cpu和内存就炸了。
# 并发池是『线程池』和『进程池』的总称
import concurrent.futures
import hashlib

def cpu_task(data):
    for _ in range(10**7):
        data = hashlib.sha256(data).digest()
    return data[:8]

if __name__ == '__main__':
    ids = [b'apple', b'banana', b'cherry', b'date']
    with concurrent.futures.ProcessPoolExecutor(max_workers=4) as executor:
        results = list(executor.map(cpu_task, ids))
    for item in results:
        print(item)
```

---

```txt
一、并发数越大就越快吗？
理论上——不是！分3种情况：
1. 小数量（比你机器CPU/硬盘/带宽低），并发数越大越快
比如你有8核，线程/进程开到8及以内，能同时干活，充分利用多核或带宽。
2. 超过临界点后，再大就不快了，反而更慢
你有8核，却开了16、32、99个进程，系统要切换调度、线程间相互抢资源，反而增加"排队"、“上下文切换”、内存消耗，导致效率变低！
网络/带宽也是，如果你有10M网速，2个下载和20个下载，20个未必更快，可能还超时/被ban。
3. 极大的时候，还可能挂掉/崩溃
内存耗尽、网络被ban、服务器拒绝服务、进程池/线程池爆了。
二、线程池/进程池，怎么选最大的数字？
- 进程池（Process）
通常和你的物理CPU核心（os.cpu_count()）一致或者略微多一两个（如果任务有IO混合）。
如果任务全是CPU算力（如图片计算等），你多开没用，8核最好就开8个。
- 线程池（Thread）
IO任务可以开得比CPU核多很多，比如100、200都不奇怪（只要没把对方服务器干趴）。
但不是越多越好，超过带宽/系统调度能力，也会有性能下降、副作用。
重度IO场景一般20-100都够用，要靠实际测试、看任务时间/数量/资源。
三、用例直观体验
比如下载一个网页需要1秒，下载50个网页，线程池设置为：

1个线程，耗时50秒（串行）
10个线程，耗时约5~6秒（开销+网络抖动）
100个线程，也许只需1~2秒，“极快”，但有的任务会被丢弃/被服务器ban/你带宽爆掉变慢
1000个线程，可能反而更慢，或者502/掉线
CPU计算同理，每个核只能干活一个，超多就是挤在门口。
```
